(set-logic QF_NRA_ODE)
(declare-fun x () Real [-15, 15])
(declare-fun v () Real [-15, 15])
(declare-fun a () Real [-15, 15])
(declare-fun lt () Real [0.000000, 0.05])
(declare-fun gt () Real [0.000000, 3])
(declare-fun tmp_0 () Real )
(declare-fun tmp1_0 () Real )
(declare-fun sub_0 () Real )
(declare-fun mul_0 () Real )
(declare-fun mul2_0 () Real )
(declare-fun add7_0 () Real )
(declare-fun state_x_0 () Real )
(declare-fun state_v_0 () Real )
(declare-fun next_a_0 () Real )
(declare-fun x_0_0 () Real [-15, 15])
(declare-fun x_0_t () Real [-15, 15])
(declare-fun v_0_0 () Real [-15, 15])
(declare-fun v_0_t () Real [-15, 15])
(declare-fun a_0_0 () Real [-15, 15])
(declare-fun a_0_t () Real [-15, 15])
(declare-fun lt_0_0 () Real [0.000000, 0.05])
(declare-fun lt_0_t () Real [0.000000, 0.05])
(declare-fun gt_0_0 () Real [0.000000, 3])
(declare-fun gt_0_t () Real [0.000000, 3])
(declare-fun time_0 () Real [0.000000, 3])
(declare-fun mode_0 () Real [1.000000, 1.000000])
(declare-fun tmp_1 () Real )
(declare-fun tmp1_1 () Real )
(declare-fun sub_1 () Real )
(declare-fun mul_1 () Real )
(declare-fun mul2_1 () Real )
(declare-fun add7_1 () Real )
(declare-fun state_x_1 () Real )
(declare-fun state_v_1 () Real )
(declare-fun next_a_1 () Real )
(declare-fun x_1_0 () Real [-15, 15])
(declare-fun x_1_t () Real [-15, 15])
(declare-fun v_1_0 () Real [-15, 15])
(declare-fun v_1_t () Real [-15, 15])
(declare-fun a_1_0 () Real [-15, 15])
(declare-fun a_1_t () Real [-15, 15])
(declare-fun lt_1_0 () Real [0.000000, 0.05])
(declare-fun lt_1_t () Real [0.000000, 0.05])
(declare-fun gt_1_0 () Real [0.000000, 3])
(declare-fun gt_1_t () Real [0.000000, 3])
(declare-fun time_1 () Real [0.000000, 3])
(declare-fun mode_1 () Real [1.000000, 1.000000])
(define-ode flow_1 ((= d/dt[gt] 1) (= d/dt[lt] 1) (= d/dt[x]  v) (= d/dt[v]  a) (= d/dt[a] 0)))
(assert (and (= lt_0_0 0) (= gt_0_0 0) (= a_0_0 0 )(= v_0_0 0 )(<= x_0_0 0.1 )(>= x_0_0 0 )(= mode_0 1)  )) 
(assert (= [gt_0_t lt_0_t x_0_t v_0_t a_0_t ] (integral 0. time_0 [gt_0_0 lt_0_0 x_0_0 v_0_0 a_0_0 ] flow_1)) ) 
(assert (and (forall_t 1 [0 time_0] (<= lt_0_t 0.01)) (<= lt_0_t 0.01) (<= lt_0_0 0.01)  )) 
(assert (and (= mode_1 1) (= lt_0_t 0.01) (= gt_1_0 gt_0_t) (= lt_1_0 0)  ))
(assert (and (= x_1_0 x_0_t)(= v_1_0 v_0_t) ))
(assert (and (= state_x_0 x_0_t ) (= state_v_0 v_0_t )  ))
(assert  (and (= tmp_1 state_x_0 )  (= tmp1_1 state_v_0 )  (= sub_1 (- 1 tmp_1 ))  (= mul_1 (* sub_1 10 ))  (= mul2_1 (* tmp1_1 3 ))  (= add7_1 (- mul_1 mul2_1 ))  (= next_a_1 add7_1 )   ) )
(assert (and (= next_a_1 a_1_0 )  ))
(assert (= [gt_1_t lt_1_t x_1_t v_1_t a_1_t ] (integral 0. time_1 [gt_1_0 lt_1_0 x_1_0 v_1_0 a_1_0 ] flow_1))  )
(assert (and (forall_t 1 [0 time_1] (<= lt_1_t 0.2))  ))
(assert (and (<= lt_1_t 0.2) (<= lt_1_0 0.2) (= mode_1 1)  ))
(assert (and (> gt_1_t 2  ) ))
(check-sat)
(exit)