/** **************************************************************************
 * IRssa.cpp
 *
 *  Created on: 11-May-2018
 *      Author: amit
 * ***************************************************************************
 * Few implementation points for later reference:
 *   Commands to run the script
 "clang -g -Xclang -disable-O0-optnone -emit-llvm -c benchmarks/test2.c -o benchmarks/test2.bc"
 "opt -loop-unroll -mem2reg -instnamer -load src/libControllerProgramPass.so -ssa  benchmarks/test2.bc -o benchmarks/test2
 "lli benchmarks/test2"
 Note:
 1) Due to the clang flag "-disable-O0-optnone" which optimize the IR instructions and eliminate all instructions
 containing alloca,load and store, thus declaration and counting of variable was not possible in the usual way.
 Moreover, if we remove this flag, then -mem2reg pass did not work and as a result IR does not become SSA (ie no phi node
 is generated by LLVM).
 So, due to the use of -mem2reg and -disable-O0-optnone flags in opt and clang, we have to use the -g flag, the debug flag.
 The use of -g enable @llvm.dbg.value instruction to appear and so we could retrieve all variables that was created.

 2) Todo:: due to our lack of understanding of llvm API, we have used string functions (find/substr) to obtain the variables name.

 Important:(invalidates the point 1)
 3) The mem2reg pass works if the two flags -O and -g i.e., "-O1/2/3 -g" used together. This combination works now
 even if "-disable-O0-optnone" flag is not present in the clang command.

 *
 * * *************************************************************************
 */

#include "IRssa.h"
#include "llvm/IR/IntrinsicInst.h"
#include "DataStructures.h"

#include <list>
#include <iostream>
#include <string>

unsigned int IRssa::ssaLineNo = 0;		//initialize the static variable


void IRssa::parseInstruction(llvm::Instruction &instruction, allStackVariables::ptr& workingVariable) {
	std::string my_inst = ""; //For every instruction it will start from the empty
	//simpleVariable < simpleVar;
	instruction.dump();

	//if (DbgDeclareInst *dbg = dyn_cast<DbgDeclareInst>(&instruction)) {
	if (CallInst *Inst = dyn_cast<CallInst>(&instruction)) {
		/* Todo: have a look at it to improve
		 */
		if (Function *F = Inst->getCalledFunction()) {
			if (F->getName().startswith("llvm.dbg.value")) {
				//std::cout<< "llvm.dbg.value Found Variable\n";
				//Value *val = dyn_cast<Value>(Inst->getArgOperand(0));
				//outs()<<"Name=" << val->getName() << "\n";
				//std::cout << "Name="<< (string) (Inst->getArgOperand(0)->getName()) << "\n";
				//outs()<<"Name=" << (*Inst->getOperand(0))<<"\n";
				std::string Str;
				raw_string_ostream OS(Str);
				OS << (*Inst->getOperand(0));	//redirecting to string variable
				OS.flush();
				//std::cout<<"Var = "<<Str<<std::endl;
				int pos = Str.find("%");	//searching the % char in the string
				//std::cout<<"% substr/var = "<<Str.substr(pos+1)<<std::endl;
				if (pos > 0) //otherwise a value creation due to optimization
					setVariable(Str.substr(pos + 1), "Real"); //Found a variable declaration

			} else if (!(F->getName().startswith("llvm."))) { //indicate that it is a function call
				string theFunction = F->getName();
				//Search this in the map and do a recursive: Note:- Take care/make sure variables are local, so that stack logic works
				std::cout<<"========= Found a call to function: "<<theFunction << "==============" <<std::endl;
				funcDump nextFunction;
				std::map<std::string, funcDump> myfuncData = getFunctionDump();
				nextFunction = myfuncData[theFunction];
				if (nextFunction.size()> 1){
					std::cout<<"Found list of Blocks/Instruction inside the Function!!\n";
					std::cout<<std::endl;	std::cout<<std::endl;


		//			convertFunctionToSSA(nextFunction, ir_ssa);


					std::cout<<"=========  "<< theFunction << "   =============" <<std::endl;
				}
			}
		}
	}				//End of function_call of llvm.dbg

	/*Allocate Instruction */
	if (isa<AllocaInst>(&instruction)) {//Will not have effect due to optimization
		AllocaInst *allocaInst = dyn_cast<AllocaInst>(&instruction);
		std::string st = "";
		my_inst.append(st);
		st = allocaInst->getName().str(); //verify replacing
		my_inst.append(st);

		//	simpleVar.varDataType = allocaInst->getAllocatedType();
		//simpleVar.varName = allocaInst->getName();
		//	simpleVar.varValue = string(0);
//		std::cout << "\t\tDefining variable = " << my_inst << ";" << std::endl;
	}
	/*STORE Instruction */
	if (isa<StoreInst>(&instruction)) {	//Will not have effect due to optimization
		std::string st = "(= ";
		my_inst.append(st);
		StoreInst *storeInst = dyn_cast<StoreInst>(&instruction);
		st = storeInst->getOperand(1)->getName();
		my_inst.append(st);
		my_inst.append(" ");

		st = getVariable_or_Value(storeInst->getOperand(0));

		//outs()<<"  Operand 1= "<< storeInst->getOperand(1)->getName();
		my_inst.append(st);
		st = " )";
		my_inst.append(st);
//		std::cout << my_inst << std::endl;
	}

	/*LOAD Instruction:  check for new version of the variables */
	if (isa<LoadInst>(&instruction)) {//Will not have effect due to optimization
		LoadInst *loadInst = dyn_cast<LoadInst>(&instruction);
		std::string st = "(= ", varType;
		my_inst.append(st);
		st = loadInst->getName(); //Note we get this lable %tmp only on running the pass -instnamer
		my_inst.append(st);	//Also a new intermediate variable is created as tmp

		if (loadInst->getType()->isIntegerTy())
			varType = "Int";
		else if (loadInst->getType()->isDoubleTy())
			varType = "Real";
		else if (loadInst->getType()->isFloatTy())
			varType = "Real";
		else
			varType = "Real";//Todo:: For now converting to real

		setVariable(st, varType);		  //Found a variable declaration
		my_inst.append(" ");
		st = loadInst->getOperand(0)->getName();
		my_inst.append(st);
		my_inst.append(" )");
//		llvm::outs() << my_inst << "\n";
	}

	if (GetElementPtrInst *getElementPtrInst = dyn_cast<GetElementPtrInst>(
			&instruction)) {
		/*
		 * We assume the the controller-program will have inputs as struct.INPUT_VAL and output as struct.RETURN_VAL
		 * To obtain the actual name of the variables of the structure. It is suggested to have a different names for
		 * variables in the program.
		 */
		string varType, varName, structName;
		unsigned int id=0;

		Type *type = getElementPtrInst->getSourceElementType();
		//std::string name = getElementPtrInst->getOperand(0)->getName();
		varName = getElementPtrInst->getName();
		varType = "Real";	//Todo:: get the actual data type either, Int or Real
		/*if (value->getType()->isIntegerTy()) {
		 varType = "Int";
		 outs() << varType << "\n";
		 } else if (value->getType()->isDoubleTy()) {
		 varType = "Real Double";
		 outs() << varType << "\n";
		 } else if (value->getType()->isFloatTy()) {
		 varType = "Real Float";
		 outs() << varType << "\n";
		}*/
		/*
		outs() << "\n====Name:"<<getElementPtrInst->getName()<<"=====";
		outs() << "\n====Operand(0)'s Name:"<<getVariable_or_Value(getElementPtrInst->getOperand(0))<<"=====";
		outs() << "\n====Operand(1)'s Name:"<<getVariable_or_Value(getElementPtrInst->getOperand(1))<<"=====";
		outs() << "\n====Operand(2)'s Name:"<<getVariable_or_Value(getElementPtrInst->getOperand(2))<<"=====";
		outs() << "\n====OpCodeName's Name:"<<getElementPtrInst->getOpcodeName()<<"=====\n";
		outs() << "\n====OpCodeName(0)'s Name:"<<getElementPtrInst->getOpcodeName(0)<<"=====\n";
		outs() << "\n====OpCodeName(1)'s Name:"<<getElementPtrInst->getOpcodeName(1)<<"=====\n";
		outs() << "\n====OpCodeName(2)'s Name:"<<getElementPtrInst->getOpcodeName(2)<<"=====\n";*/

		//if it is a structure , then two operands structname(0) and index(1)
		if (type->getTypeID() == Type::StructTyID) {
			structName = type->getStructName();
			string num = getVariable_or_Value(getElementPtrInst->getOperand(2));
			id = stoi(num);

			if (boost::iequals(structName, "struct.INPUT_VAL")){	//indicates the INPUT variables
				setInputVariable(varName, id, varType);
			} else if (boost::iequals(structName, "struct.RETURN_VAL")){	//indicates the OUTPUT variables
				setOutputVariable(varName, id, varType);
			}
		}
	}

	//Type casting instruction
	if (isa<SIToFPInst>(instruction)) {
		SIToFPInst *siToFPInst = dyn_cast<SIToFPInst>(&instruction);
		std::string st = "(= ", varType;
		my_inst.append(st);
		st = siToFPInst->getName();
		my_inst.append(st);
		my_inst.append(" ");

		//Todo get the type... Need to verify with the program using siToFp in IR
		if (siToFPInst->getType()->isIntegerTy())
			varType = "Int";
		else if (siToFPInst->getType()->isDoubleTy())
			varType = "Real";
		else if (siToFPInst->getType()->isFloatTy())
			varType = "Real";
		else
			varType = "Real";//Todo:: For now converting to real

		setVariable(st, varType);					//Found a variable declaration
		st = getVariable_or_Value(siToFPInst->getOperand(0));
		my_inst.append(st);
		st = " )";
		my_inst.append(st);
	}


	if (isa<ZExtInst>(instruction)) {

		ZExtInst *zExtInst = dyn_cast<ZExtInst>(&instruction);
		std::string st, varType, convertBoolExp;
//		outs()<<"getVariable_or_Value(zExtInst->getOperand(0)) = "<<getVariable_or_Value(zExtInst->getOperand(0))<<"\n";
//		outs()<<"zExtInst->getName() = "<<zExtInst->getName()<<"\n";
		convertBoolExp.append("(ite ");
		convertBoolExp.append(getVariable_or_Value(zExtInst->getOperand(0)));
		convertBoolExp.append(" (= ");
		convertBoolExp.append(zExtInst->getName());
		convertBoolExp.append(" 1)");

		convertBoolExp.append(" (= ");
		convertBoolExp.append(zExtInst->getName());
		convertBoolExp.append(" 0))");

		//outs()<<"convertBoolExp = "<<convertBoolExp<<"\n";
		my_inst.append(convertBoolExp);
		//Todo get the type... Need to verify with the program using IR
		if (zExtInst->getType()->isIntegerTy())
			varType = "Int";
		else if (zExtInst->getType()->isDoubleTy())
			varType = "Real";
		else if (zExtInst->getType()->isFloatTy())
			varType = "Real";
		else
			varType = "Real";		//Todo:: For now converting to real
		st=zExtInst->getName();//Found a variable declaration
		setVariable(st, varType);

		/*st = "(= ";
		my_inst.append(st);
		st = zExtInst->getName();
		my_inst.append(st);
		my_inst.append(" ");
		setVariable(st, varType);				//Found a variable declaration
		st = getVariable_or_Value(zExtInst->getOperand(0));
		my_inst.append(st);
		st = ")";
		my_inst.append(st);*/
	}


	if (isa<SelectInst>(&instruction)) {	//Handling only simple i1 type instruction
		/*
		 * Syntax:   <result> = select selty <cond>, <ty> <val1>, <ty> <val2>   ; yields ty
		 * (ite cond (res = val1) (res = val2))
		 */

		SelectInst *selectInst = dyn_cast<SelectInst>(&instruction);
		std::string st = "(ite ", cond, TrueExp, FalseExp, varType;
		cond = getVariable_or_Value(selectInst->getOperand(0));

		setVariable(cond, "Bool");	//if already declared will be ignored
		TrueExp.append("(= ");
		TrueExp.append(selectInst->getName());

		//Todo get the type... Need to verify with the program using IR
		if (selectInst->getType()->isIntegerTy())
			varType = "Int";
		else if (selectInst->getType()->isDoubleTy())
			varType = "Real";
		else if (selectInst->getType()->isFloatTy())
			varType = "Real";
		else
			varType = "Real";		//Todo:: For now converting to real

		setVariable(selectInst->getName(), varType);
		TrueExp.append(" ");
		TrueExp.append(getVariable_or_Value(selectInst->getOperand(1)));
		TrueExp.append(" )");

		FalseExp.append("(= ");
		FalseExp.append(selectInst->getName());
		FalseExp.append(" ");
		FalseExp.append(getVariable_or_Value(selectInst->getOperand(2)));
		FalseExp.append(" )");			//totalExpr = st + cond + TrueExp + FalseExp + ")";

		my_inst.append(st);
		my_inst.append(cond);
		my_inst.append(" ");
		my_inst.append(TrueExp);
		my_inst.append(FalseExp);
		my_inst.append(" )");

	}

	/*
	 * Redesign icmp and fcmp instruction, since there can be compound(use of && and ||) conditional statements.
	 * The "instruction.getOpcodeName()" returns the operation name. It returns 'and' or 'or' after two or more successive icmp/fcmp instructions
	 * in which case a single 'ite' smt SSA-code is to be generated for the previous two icmp/fcmp instructions.
	 */
	/*if (CmpInst *cmpInst = dyn_cast<CmpInst>(&instruction)) { //Compare Instruction: are of type ICmpInst and FCmpInst
		//std::cout<<"Found Compare instruction\n";
		struct phiData condition_data;
		if (ICmpInst *IcmpInst = dyn_cast<ICmpInst>(&instruction)) { //integer operations
			std::string st = "", cmp_condtion = "";
			//std::pair<std::string, std::string> condition_data;	//outs()<<"Condition Name="<<IcmpInst->getName()<<"\n";
			condition_data.blockLabel = getCurrentBlockName();
			condition_data.condName = IcmpInst->getName();
			st = "(ite (";	//llvm::outs() << " (ite (> ";
			my_inst.append(st);
			cmp_condtion.append("(");
			cmp_condtion.append(getOperator_Integer(IcmpInst->getPredicate()));
			//cmp_condtion =getOperator_Integer(IcmpInst->getSignedPredicate());
			//std::cout<<"Cmp condition = "<<cmp_condtion<<"\n";
			st = getVariable_or_Value(IcmpInst->getOperand(0));
			cmp_condtion.append(st);
			cmp_condtion.append(" ");
			st = getVariable_or_Value(IcmpInst->getOperand(1));
			//my_inst.append(IcmpInst->getOperand(1)->getName());
			cmp_condtion.append(st);
			cmp_condtion.append(") ");
			my_inst.append(cmp_condtion);
			//std::cout<<"Cmp condition = "<<cmp_condtion<<"\n";
			condition_data.conditionExp = cmp_condtion;
			pushTop(condition_data);//Storing the cmp_conditional at the top of the stack data-structure
		} else if (FCmpInst *FcmpInst = dyn_cast<FCmpInst>(&instruction)) {//Conditional statement on Floating operations
			std::string st = "", cmp_condtion = "";
			//std::pair<std::string, std::string> condition_data;
			condition_data.blockLabel= getCurrentBlockName();
			condition_data.condName = FcmpInst->getName();
			st = "(ite (";	//llvm::outs() << " (ite (> ";
			my_inst.append(st);
			//std::cout << "Condition good" << std::endl;
			cmp_condtion.append("(");
			cmp_condtion.append(getOperator_Float(FcmpInst->getPredicate()));
			//std::cout << "Cmp condition = " << cmp_condtion << "\n";
			st = getVariable_or_Value(FcmpInst->getOperand(0));
			cmp_condtion.append(st);
			cmp_condtion.append(" ");
			st = getVariable_or_Value(FcmpInst->getOperand(1));
			//my_inst.append(IcmpInst->getOperand(1)->getName());
			cmp_condtion.append(st);
			cmp_condtion.append(") ");
			my_inst.append(cmp_condtion);
			//std::cout<<"Cmp condition = "<<cmp_condtion<<"\n";
			condition_data.conditionExp = cmp_condtion;
			pushTop(condition_data);//Storing the cmp_conditional at the top of the stack data-structure
		}
	}*/

	if (CmpInst *cmpInst = dyn_cast<CmpInst>(&instruction)) { //Compare Instruction: are of type ICmpInst and FCmpInst
		struct phiData condition_data;
		std::string st = "", cmp_condtion = "", cmp_str="", varType="Bool", operatorSign;

		if (ICmpInst *IcmpInst = dyn_cast<ICmpInst>(&instruction)) { //integer operations
			condition_data.blockLabel = workingVariable->getCurrentBlockName();
			condition_data.condName = IcmpInst->getName();

			setVariable(IcmpInst->getName(), varType);

			//cmp_condtion.append("(");
			operatorSign = getOperator_Integer(IcmpInst->getPredicate());
			if (boost::iequals(operatorSign, "!= ")){	//not (= op1 op2) :Note the space in "!= "
				cmp_condtion.append("(not (= ");
				//cmp_condtion.append(operatorSign);//outs()<<"\nFound != comparison\n\n";
				cmp_condtion.append(" ");
				st = getVariable_or_Value(IcmpInst->getOperand(0));
				cmp_condtion.append(st);
				cmp_condtion.append(" ");
				st = getVariable_or_Value(IcmpInst->getOperand(1));
				cmp_condtion.append(st);
				cmp_condtion.append(" ))");
			} else {
				cmp_condtion.append("(");
				cmp_condtion.append(operatorSign);
				cmp_condtion.append(" ");
				st = getVariable_or_Value(IcmpInst->getOperand(0));
				cmp_condtion.append(st);
				cmp_condtion.append(" ");
				st = getVariable_or_Value(IcmpInst->getOperand(1));
				cmp_condtion.append(st);
				cmp_condtion.append(" )");
			}

			cmp_str.append("(= ");
			cmp_str.append(IcmpInst->getName());
			cmp_str.append(" ");
			cmp_str.append(cmp_condtion);
			cmp_str.append(" )");
		//	my_inst.append(cmp_str);
		} else if (FCmpInst *FcmpInst = dyn_cast<FCmpInst>(&instruction)) { //Conditional statement on Floating operations
			//std::string st = "", cmp_condtion = "";
			condition_data.blockLabel = workingVariable->getCurrentBlockName();
			condition_data.condName = FcmpInst->getName();

			setVariable(FcmpInst->getName(), varType);

			operatorSign = getOperator_Float(FcmpInst->getPredicate());
			if (boost::iequals(operatorSign, "!= ")) {	//not (= op1 op2)
				cmp_condtion.append("(not (= ");
				//cmp_condtion.append(operatorSign);//outs() << "\nFound != comparison in Float\n\n";
				cmp_condtion.append(" ");
				st = getVariable_or_Value(FcmpInst->getOperand(0));
				cmp_condtion.append(st);
				cmp_condtion.append(" ");
				st = getVariable_or_Value(FcmpInst->getOperand(1));
				cmp_condtion.append(st);
				cmp_condtion.append(" ))");
			} else {
				cmp_condtion.append("(");
				cmp_condtion.append(operatorSign);
				cmp_condtion.append(" ");
				st = getVariable_or_Value(FcmpInst->getOperand(0));
				cmp_condtion.append(st);
				cmp_condtion.append(" ");
				st = getVariable_or_Value(FcmpInst->getOperand(1));
				cmp_condtion.append(st);
				cmp_condtion.append(" )");
			}

			cmp_str.append("(= ");
			cmp_str.append(FcmpInst->getName());
			cmp_str.append(" ");
			cmp_str.append(cmp_condtion);
			cmp_str.append(" )");

			//my_inst.append(cmp_str);

			//my_inst.append(cmp_condtion);
			//condition_data.conditionExp = cmp_condtion;
			//pushTop(condition_data);//Storing the cmp_conditional at the top of the stack data-structure
		}
		condition_data.conditionExp = cmp_condtion;
		workingVariable->pushTop(condition_data); //Storing the cmp_conditional at the top of the stack data-structure
		my_inst.append(cmp_str);
	//	llvm::outs()<<"condition: "<<cmp_str<<"\n";
	}

	//if (isa < BranchInst > (&instruction)) {
	if (isa<BranchInst>(&instruction)) {
/*Note:
 * 1) If False branch executes first in sequence, then the condition is negated and open bracket begins.
 * 2) Otherwise no Negation is printed and open bracket begins.
 * 3) If either one of the True/False branch is executed first and the other branch is executed immediately
 *    after it then, it has both if-then-else parts and so use "ite" as smt.
 * 4) After the end of one block with the last instruction as conditional br instruction. As soon as one of the
 *    True/False branch is executed and the next consecutive block executed is not the other branch/block of the conditional br instruction
 *    then, the condition does not have the else-part (i.e., it only has the then-part).
 * 5) Note that the printing of the sequences of '(' or ')' brackets are based on these br labels handled properly using some stack like structure.
 *
 */
		//Todo: handle printing of ite here with appropriate logic of either ite or => (implies)

//		llvm::outs() << "\n=========Branching statement========\n";
		BranchInst *branchInst = dyn_cast<BranchInst>(&instruction);
		struct brData brInfo;
		//llvm::outs() << branchInst->getOperand(0)->getName()<<"\n";
		//llvm::outs() << branchInst->getNumSuccessors()<<"\n";
		unsigned int brNumber=branchInst->getNumSuccessors();

		if (!(branchInst->isConditional())){	//if True has both True and False parts, otherwise on single label
			workingVariable->setPreviousBlockCondition(false);	//not a conditional br instruction
			//outs()<<"Single br label = " << branchInst->getOperand(0)->getName();
			workingVariable->setPrevious_br_label(branchInst->getOperand(0)->getName());
			ssaLineNo++;
			setInst(ssaLineNo, " )");
			return;//Does not have both True and False parts
		} else{
			workingVariable->setPreviousBlockCondition(true);	//is a conditional br instruction
//			llvm::outs() << branchInst->getOperand(0)->getName() << "\n";//branch condition Name
//			llvm::outs() << branchInst->getOperand(1)->getName() << "\n"; // False-label
//			llvm::outs() << branchInst->getOperand(2)->getName()<<"\n";	//True-label
			brInfo.br_inBlock = workingVariable->getCurrentBlockName();
			brInfo.brConditionName = branchInst->getOperand(0)->getName();
			brInfo.falseLabel = branchInst->getOperand(1)->getName();
			brInfo.trueLabel = branchInst->getOperand(2)->getName();

			std::pair<unsigned int, std::string> TrueFalseData;

			TrueFalseData.first = ssaLineNo + 1; // ssaLineNo+1 is going to be written for this ssa-string
			TrueFalseData.second = brInfo.trueLabel;

			workingVariable->setTrueFalseBlockStack(TrueFalseData);	//pushed TrueLabel in the Working stack

			TrueFalseData.second = brInfo.falseLabel;
			workingVariable->setTrueFalseBlockStack(TrueFalseData);	//pushed FalseLabel in the Working stack

			workingVariable->setBrStack(brInfo);	//USE THIS DATA-structure FOR PHI-NODE processing and NOT THE phiData data-structure

			my_inst.append("(ite "); //1) use if wisely to determine 'ite' or '=>'
									 //2) do some back-tracking to replace 'ite' with '=>'
			my_inst.append(brInfo.brConditionName);//Condition
			my_inst.append(" ");
		//	my_inst.append("(");	//Since it is a conditional instruction, so the start of the True/False block
		}
	}

	/*Binary Operation Instruction: Example add */
	if (isa<BinaryOperator>(instruction)) {
//		llvm::outs() << "Binary Operator";
		BinaryOperator *binaryOperator = cast<BinaryOperator>(&instruction);
		string st = "", varType;

		switch (binaryOperator->getOpcode()) {
		case llvm::Instruction::Add: {
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(+ ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )");
			my_inst.append(")");
			break;
		}	//End of Case::Add
		case llvm::Instruction::Sub: {
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(- ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )");
			my_inst.append(")");
			break;
		}	//End of Case::Sub
		case llvm::Instruction::Mul: {
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(* ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )");
			my_inst.append(")");
			break;
		}	//End of Case::Mul
		case llvm::Instruction::FAdd: {
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(+ ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )");
			my_inst.append(")");
			break;
		}	//End of Case::FAdd
		case llvm::Instruction::FSub: {
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(- ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )");
			my_inst.append(")");
			break;
		}	//End of Case::FSub
		case llvm::Instruction::FMul: {
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(* ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )");
			my_inst.append(")");
			break;
		}	//End of Case::FMul
		case llvm::Instruction::UDiv: {	//unsigned integer division
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(/ ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )");
			my_inst.append(")");
			break;
		}	//End of Case::UDiv
		case llvm::Instruction::SDiv: {	//signed integer division
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(/ ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )");
			my_inst.append(")");
			break;
		}	//End of Case::SDiv
		case llvm::Instruction::FDiv: {	//float-point division
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(/ ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )");
			my_inst.append(")");
			break;
		}	//End of Case::FDiv

		case llvm::Instruction::And: {//Handle phi-node for compound conditions
			//Indicate that it has found and operator for some comparison operators prior to this. So pop all for this block and do ANDing
			struct phiData phiNode1, phiNode2;
			phiNode1 = workingVariable->getTop();

			workingVariable->setAllCompoundConditions(phiNode1);


			string st = "(and ";
			//			outs()<<"Found stack size="<<getCondStack().size()<<"\n";
			//			outs()<<"phiNode1.condition="<<phiNode1.conditionExp<<"\n";
			//Todo:: re-think of NOT expanding/replacing the and/or compound conditions instead just use
			//condName and ANDing/ORing

			while (!(workingVariable->getCondStack().empty())) {
				phiNode2 = workingVariable->getTop();
				if (boost::iequals(phiNode1.blockLabel, phiNode2.blockLabel)) {
					workingVariable->setAllCompoundConditions(phiNode2);
					phiNode1.condName = binaryOperator->getName(); //replace new label/variable Name

					st.append(phiNode1.conditionExp);
					st.append(phiNode2.conditionExp);
					phiNode1.conditionExp = st;	//replace new expression with ANDing
					st = "";
				} else { //we have popTop but not matching So have to push in
					workingVariable->pushTop(phiNode2); //push back
				}
			}
			phiNode1.conditionExp.append(" )");
			workingVariable->pushTop(phiNode1); //Now replacing the new ANDed expression
			//			outs()<<"And = "<<phiNode1.conditionExp<<"\n";
			//			outs()<<"Found stack size="<<getCondStack().size()<<"\n";

			/*unsigned int totalConditions;
			 totalConditions = binaryOperator->getNumOperands();
			 std::cout<<"totalConditions="<<totalConditions<<std::endl;
			 outs()<<binaryOperator->getOperand(0)->getName()<<"\n";
			 outs()<<binaryOperator->getOperand(1)->getName()<<"\n";*/
			string andConditions = "";

			andConditions.append("(= ");
			andConditions.append(binaryOperator->getName());

			st = binaryOperator->getName();
			varType= "Bool";
			setVariable(st, varType);	//Found a variable declaration


			andConditions.append(" (and ");
			andConditions.append(binaryOperator->getOperand(0)->getName());
			andConditions.append(" ");
			andConditions.append(binaryOperator->getOperand(1)->getName());
			andConditions.append(" ))");
			my_inst.append(andConditions);
			break;
		}
		case llvm::Instruction::Or: {//Handle phi-node for compound conditions
			//Indicate that it has found and operator for some comparison operators prior to this. So pop all for this block and do ORing
			//			outs() << "OpcodeName()="<< binaryOperator->getOpcodeName() << "\n";
			//			outs() << "Operand(0)="<< binaryOperator->getOperand(0)->getName() << "\n";
			//			outs() << "Operand(1)="<< binaryOperator->getOperand(1)->getName() << "\n";
			struct phiData phiNode1, phiNode2;
			phiNode1 = workingVariable->getTop();
			workingVariable->setAllCompoundConditions(phiNode1);
			string st = "(or ";
			//			outs()<<"Found stack size="<<getCondStack().size()<<"\n";
			//			outs()<<"phiNode1.condition="<<phiNode1.conditionExp<<"\n";
			while (!(workingVariable->getCondStack().empty())) {
				phiNode2 = workingVariable->getTop();
				if (boost::iequals(phiNode1.blockLabel, phiNode2.blockLabel)) {
					workingVariable->setAllCompoundConditions(phiNode2);
					phiNode1.condName = binaryOperator->getName(); //replace new label/variable Name
					st.append(phiNode1.conditionExp);
					st.append(phiNode2.conditionExp);
					phiNode1.conditionExp = st;	//replace new expression with ANDing
					st = "";
				} else { //we have popTop but not matching So have to push in
					workingVariable->pushTop(phiNode2); //push back
					break;
				}
			}
			phiNode1.conditionExp.append(" )");
			workingVariable->pushTop(phiNode1); //Now replacing the new ANDed expression
			//			outs()<<"OR = "<<phiNode1.conditionExp<<"\n";

			string andConditions = "";

			andConditions.append("(= ");
			andConditions.append(binaryOperator->getName());
			st = binaryOperator->getName();

			varType= "Bool";
			setVariable(st, varType);	//Found a variable declaration

			andConditions.append(" (or ");
			andConditions.append(binaryOperator->getOperand(0)->getName());
			andConditions.append(" ");
			andConditions.append(binaryOperator->getOperand(1)->getName());
			andConditions.append(" ))");
			my_inst.append(andConditions);
			break;
		}
		case llvm::Instruction::Shl: {
			//Syntax: result = shl x , n // will yields result = x * (2^n): Prefix:  (= result (* x (^ 2 n)))
			//outs()<<"found shl instruction !!!\n";
			st = "(= ";
			my_inst.append(st);
			st = binaryOperator->getName();

			//Todo get the type... Need to verify with the program using IR
			if (binaryOperator->getType()->isIntegerTy())
				varType = "Int";
			else if (binaryOperator->getType()->isDoubleTy())
				varType = "Real";
			else if (binaryOperator->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);	//Found a variable declaration

			my_inst.append(st);
			my_inst.append(" ");

			Value *operand1 = binaryOperator->getOperand(0);
			Value *operand2 = binaryOperator->getOperand(1);
			st = "(* ";
			my_inst.append(st);
			st = getVariable_or_Value(operand1);
			my_inst.append(st);
			my_inst.append(" ");

			st = "(^ 2 ";
			my_inst.append(st);

			st = getVariable_or_Value(operand2);
			my_inst.append(st);
			my_inst.append(" )))");
			break;
		}
		}	//End of Switch

	}	//End of BinaryOperator

	if (isa<CallInst>(instruction)) {

	}

	/*
	 * Logic as per my understanding (so far): when phi-node is found
	 *   The working stack data structure is searched for the incoming blockName, if found then get the conditionExp
	 *   and use as the phi-condtion for assignment. If the stack does not contain the blockName then it indicate that
	 *   the incoming block has no conditional instruction thus, only a simple assignment is required in this case.
	 *   Note here the stack is not deleted (as I guess not need in this algorithm)
	 */
	if (isa<PHINode>(instruction)) {
		string st = "", varType;
		PHINode *phiNode = cast<PHINode>(&instruction);
		unsigned numberOfIncomingBlock = phiNode->getNumIncomingValues();
		string currBlockName=workingVariable->getCurrentBlockName();
		std::list<blockOrdering> blockSequence =  workingVariable->getBlockSequence();
		std::list<brData> brInfo = workingVariable->getBrStack();

		for (int i = 0; i < numberOfIncomingBlock; i++) {
			st = phiNode->getName();//New variable/label name

			if (phiNode->getType()->isIntegerTy())
				varType = "Int";
			else if (phiNode->getType()->isDoubleTy())
				varType = "Real";
			else if (phiNode->getType()->isFloatTy())
				varType = "Real";
			else
				varType = "Real";		//Todo:: For now converting to real
			setVariable(st, varType);

			string cond = "", incomingBlockLabel;
			incomingBlockLabel = phiNode->getIncomingBlock(i)->getName();
			bool found;// = searchBlock(getCondStack(), incomingBlockLabel, cond);//return cond varName

			found = searchPhiCondition(blockSequence, brInfo, currBlockName, incomingBlockLabel, cond); //Correct implementation

			if (found){ //Need to print implication (=> (condition)(assignment/true-part)
				my_inst.append("(=> ");
				my_inst.append(cond);
				my_inst.append(" (= ");
				my_inst.append(st);
				my_inst.append(" ");
				my_inst.append(getVariable_or_Value(phiNode->getOperand(i)));
				my_inst.append(" ))");
			}//At the moment I do not see other possible condition
			/*else{	//Not found indicate just need to have simple assignment
				my_inst.append(" (= ");
				my_inst.append(st);
				my_inst.append(" ");
				my_inst.append(getVariable_or_Value(phiNode->getOperand(i)));
				my_inst.append(")");
			}*/

			if (i!=(numberOfIncomingBlock-1))
				my_inst.append("\n");
		}
	}

	if (my_inst.compare("") != 0){
		ssaLineNo++;
		setInst(ssaLineNo, my_inst);
		//all_insts.push_back(my_inst);
	}
}

std::list<std::pair<unsigned int, std::string> > IRssa::getAllInsts() {
	return all_insts;
}

/*bool IRssa::replaceAllInsts(std::string searchSt, std::string replacingSt){
	for(std::list<std::string>::reverse_iterator rev_it = all_insts.rbegin(); rev_it != all_insts.rend(); ++rev_it){
		if (boost::iequals((*rev_it),searchSt)){	//look for the first matching string
			(*rev_it) = replacingSt;	//std::cout<<"Test (iterator) Found matching!!!\n";
			//break;
			return true;
		}
	}
//	(*it) = replacingSt;	//replacing with the modified smt string
	return false;
}*/

bool IRssa::replaceAllInsts(std::string searchSt, std::string replacingSt){
	for(std::list<std::pair<unsigned int, std::string> >::reverse_iterator rev_it = all_insts.rbegin(); rev_it != all_insts.rend(); ++rev_it){
		if (boost::iequals((*rev_it).second, searchSt)){	//look for the first matching string
			(*rev_it).second = replacingSt;	//std::cout<<"Test (iterator) Found matching!!!\n";
			return true;
		}
	}
	return false;
}

bool IRssa::replacePrevious_ite_toImplication(std::pair<unsigned int, std::string> item){

	for(std::list<std::pair<unsigned int, std::string> >::reverse_iterator rev_it = all_insts.rbegin(); rev_it != all_insts.rend(); ++rev_it){
		if ((*rev_it).first == item.first){	//look for the matching ssaLineNo
			//std::cout<<"Found matching = "<<(*rev_it).second<<" !!!\n";
			std::string oldSSA = (*rev_it).second;
			// ***** Do replacement Logic here *****
			boost::replace_first(oldSSA, "ite","=>");// replace_all() replaces all occurrence at once
			(*rev_it).second = oldSSA;	//replacing with the modified ssa string
			// ***** End of replacement Logic *****
			return true;
		}
	}
	return false;
}

void IRssa::setInst(unsigned int lineNo, std::string st) {
	std::pair<unsigned int, std::string>  ssa_str;
	ssa_str.first = lineNo;
	ssa_str.second = st;
	all_insts.push_back(ssa_str);
}

std::list<std::pair<std::string, std::string> > IRssa::getVariables() {
	return ssaVariables;
}
void IRssa::setVariable(std::string varName, std::string VarType) {
	bool found = false;
	std::list<std::pair<std::string, std::string> >::iterator it;
	for (it = ssaVariables.begin(); it != ssaVariables.end(); it++) {
		if (boost::iequals((*it).first, varName))
			found = true;
	}
	if (!found){ //not a duplicate variable
		std::pair<std::string, std::string> temp;
		temp.first = varName;
		temp.second = VarType;
		ssaVariables.push_back(temp);
	}
}

std::list<variable> IRssa::getInputVariables(){
	return inputVariables;
}
void IRssa::setInputVariable(std::string varName, unsigned int id, std::string VarType){
	bool found = false;
	variable inputVar;
	std::list<variable>::iterator it;
	for (it = inputVariables.begin(); it != inputVariables.end(); it++) {
		if (boost::iequals((*it).varName, varName)){
			found = true;
			break;
		}
	}
	if (!found) { //not a duplicate variable
		inputVar.varName = varName;
		inputVar.varType = VarType;
		inputVar.id = id;
		inputVar.versionNames.push_back(varName);
		inputVariables.push_back(inputVar);
	}
}

std::list<variable> IRssa::getOutputVariables(){
	return outputVariables;
}
void IRssa::setOutputVariable(std::string varName, unsigned int id, std::string VarType) {
	bool found = false;
	variable outputVar;
	std::list<variable>::iterator it;
	for (it = outputVariables.begin(); it != outputVariables.end(); it++) {
		if (boost::iequals((*it).varName, varName)) {
			found = true;
			break;
		}
	}
	if (!found) { //not a duplicate variable
		outputVar.varName = varName;
		outputVar.varType = VarType;
		outputVar.id = id;
		outputVar.versionNames.push_back(varName);
		outputVariables.push_back(outputVar);
	}
}











const std::map<std::string, funcDump>& IRssa::getFunctionDump() const {
	return functionDump;
}

void IRssa::setFunctionDump(const std::map<std::string, funcDump>& functionDump) {
	this->functionDump = functionDump;
}
